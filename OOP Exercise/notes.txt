# OOP Exercise - Comprehensive Notes
# Complete Guide to Methods, Keywords, and Use Cases

## TABLE OF CONTENTS
1. Python Keywords Used
2. Built-in Functions Used
3. Special Methods (Dunder Methods)
4. User-Defined Classes and Methods
5. OOP Concepts Demonstrated
6. Mathematical and String Operations
7. File-by-File Analysis
8. Programming Patterns and Best Practices

================================================================================

## 1. PYTHON KEYWORDS USED

### Core Keywords:
- **class**: Defines a new class (blueprint for objects)
  - Usage: `class Vehicle:`, `class Bus(Vehicle):`
  - Creates user-defined data types with attributes and methods

- **def**: Defines functions and methods
  - Usage: `def __init__(self):`, `def show(self):`
  - Creates callable code blocks within classes

- **self**: Reference to the current instance of a class
  - Usage: `self.name = name`, `self.show()`
  - Allows access to instance attributes and methods

- **super()**: Function to access parent class methods and attributes
  - Usage: `super().__init__()`, `super().fare()`
  - Enables method overriding while maintaining parent functionality

- **pass**: Null operation placeholder
  - Usage: Used in empty classes and methods
  - Syntactically required when no code execution is needed

- **import**: Imports external modules
  - Usage: `import math`
  - Provides access to additional functionality

- **return**: Returns values from functions/methods
  - Usage: `return self.capacity * 100`
  - Sends data back to the caller

- **raise**: Raises exceptions
  - Usage: `raise NotImplementedError("message")`
  - Forces error conditions for abstract methods

### Control Flow Keywords:
- **for**: Loop iteration
  - Usage: `for shape in shapes:`
  - Iterates over sequences

- **in**: Membership operator
  - Usage: Used in for loops and conditional checks
  - Tests if item exists in sequence

### Boolean Keywords:
- **True/False**: Boolean literals
  - Usage: Return values from isinstance(), issubclass()
  - Represent boolean states

================================================================================

## 2. BUILT-IN FUNCTIONS USED

### Output Functions:
1. **print()** - Display output to console
   - Usage: `print(f'max speed: {self.max_speed}')`
   - Variations: Simple print, f-string formatting, multiple arguments

### Type Checking Functions:
2. **type()** - Returns the exact type of an object
   - Usage: `print(type(School_bus))`
   - Returns: `<class '__main__.Bus'>`
   - Use Case: Determine exact class of an object

3. **isinstance()** - Checks if object is instance of a class
   - Usage: `isinstance(School_bus, Vehicle)`
   - Returns: True/False
   - Use Case: Verify inheritance relationships for objects

4. **issubclass()** - Checks if class is subclass of another
   - Usage: `issubclass(Dog, Animal)`
   - Returns: True/False
   - Use Case: Verify class inheritance hierarchy

### Inheritance Functions:
5. **super()** - Access parent class methods
   - Usage: `super().__init__(name, max_speed, mileage)`
   - Use Case: Call parent constructors and methods in child classes

### String Formatting:
6. **f-string formatting** - String interpolation
   - Usage: `f'max speed: {self.max_speed}'`
   - Use Case: Dynamic string creation with variable values

================================================================================

## 3. SPECIAL METHODS (DUNDER METHODS)

### Constructor Method:
- **__init__()** - Object initialization method
  - Purpose: Initialize object state when created
  - Usage: `def __init__(self, name, max_speed, mileage):`
  - Called automatically when object is instantiated
  - Sets up instance attributes

================================================================================

## 4. USER-DEFINED CLASSES AND METHODS

### Base Classes:

#### Vehicle Class (Primary base class):
**Attributes:**
- `name` - Vehicle name (string)
- `max_speed` - Maximum speed (integer)
- `mileage` - Fuel efficiency (integer)
- `capacity` - Seating capacity (integer)
- `color` - Class attribute (string, default "White")

**Methods:**
- `__init__()` - Constructor for initialization
- `show()` - Display vehicle information
- `mileage()` - Display mileage information
- `seating_capacity()` - Return seating capacity info
- `fare()` - Calculate fare based on capacity

#### Shape Class (Abstract base class):
**Methods:**
- `area()` - Abstract method that raises NotImplementedError
- Purpose: Define interface for shape subclasses

#### Animal Class (Simple base class):
**Purpose:** Demonstrate inheritance hierarchy
**Implementation:** Empty class with pass statement

### Child Classes:

#### Bus Class (Inherits from Vehicle):
**Inheritance Features:**
- Inherits all Vehicle attributes and methods
- Overrides specific methods for Bus-specific behavior
- Uses super() to call parent methods

**Method Overrides:**
- `seating_capacity()` - Adds default parameter (capacity=50)
- `fare()` - Adds 10% maintenance charge to base fare

#### Car Class (Inherits from Vehicle):
**Implementation:** Simple inheritance with pass statement
**Purpose:** Demonstrate basic inheritance without method overriding

#### Circle Class (Inherits from Shape):
**Attributes:**
- `radius` - Circle radius (numeric)

**Methods:**
- `__init__(radius)` - Initialize with radius
- `area()` - Calculate area using π × r²

#### Square Class (Inherits from Shape):
**Attributes:**
- `side` - Square side length (numeric)

**Methods:**
- `__init__(side)` - Initialize with side length
- `area()` - Calculate area using side²

#### Dog, Puppy, Cat Classes:
**Purpose:** Demonstrate multi-level inheritance
**Implementation:** Empty classes for inheritance testing

================================================================================

## 5. OOP CONCEPTS DEMONSTRATED

### 5.1 Class Definition and Object Creation
**Concept:** Creating blueprints for objects
**Examples:**
```python
class Vehicle:  # Class definition
    pass

car = Vehicle()  # Object instantiation
```

### 5.2 Instance vs Class Attributes
**Instance Attributes:**
- Unique to each object
- Defined in __init__ method
- Examples: `self.name`, `self.max_speed`

**Class Attributes:**
- Shared by all instances
- Defined at class level
- Example: `color = "White"`
- Access: `self.color` or `ClassName.color`

### 5.3 Inheritance Types

#### Single Inheritance:
- One parent class
- Example: `class Bus(Vehicle):`

#### Multi-level Inheritance:
- Chain of inheritance
- Example: `Puppy -> Dog -> Animal`

### 5.4 Method Overriding
**Purpose:** Child class provides specific implementation
**Examples:**
- `Bus.fare()` overrides `Vehicle.fare()`
- `Circle.area()` implements abstract `Shape.area()`

### 5.5 Polymorphism
**Concept:** Same method name, different implementations
**Example:**
```python
shapes = [Circle(5), Square(7)]
for shape in shapes:
    print(shape.area())  # Different area calculations
```

### 5.6 Abstract Methods
**Purpose:** Force subclasses to implement specific methods
**Implementation:** `raise NotImplementedError()`

### 5.7 Constructor Chaining
**Purpose:** Initialize parent class attributes
**Usage:** `super().__init__(parameters)`

================================================================================

## 6. MATHEMATICAL AND STRING OPERATIONS

### Mathematical Operations:
1. **Multiplication:**
   - `self.capacity * 100` (fare calculation)
   - `math.pi * (self.radius ** 2)` (circle area)

2. **Exponentiation:**
   - `self.radius ** 2` (radius squared)
   - `self.side ** 2` (side squared)

3. **Addition:**
   - `total_fare + (total_fare * .10)` (fare with maintenance)

4. **Percentage Calculation:**
   - `total_fare * .10` (10% maintenance charge)

### String Operations:
1. **F-string Formatting:**
   - `f'max speed: {self.max_speed}'`
   - `f'Vehicle Name: {self.name} Speed: {self.max_speed}'`

2. **String Concatenation:**
   - Return statements with formatted strings

3. **Precision Formatting:**
   - `f'{shape.area():.2f}'` (2 decimal places)

================================================================================

## 7. FILE-BY-FILE ANALYSIS

### 01_class_with_attributes.py
**Purpose:** Basic class structure with attributes and methods
**Key Concepts:**
- Class definition with constructor
- Instance attributes (`max_speed`, `mile`)
- Instance methods (`show()`, `mileage()`)
- Object creation and method calling
- Direct attribute access

**Methods Used:**
- `__init__(self, max_speed, mile)`
- `show(self)` - displays max speed
- `mileage(self)` - displays mileage

### 02_empty_vehicle_class.py
**Purpose:** Demonstrate empty class creation
**Key Concepts:**
- Empty class using `pass` statement
- Object instantiation from empty class
- Syntactic requirements for class definition

**Keywords:** `class`, `pass`

### 03_bus_inheritance.py
**Purpose:** Basic inheritance implementation
**Key Concepts:**
- Child class inheriting from parent
- Constructor chaining with `super()`
- Method implementation in child class

**Methods Used:**
- `super().__init__(name, max_speed, mileage)`
- `show(self)` - displays all vehicle information

### 04_class_inheritance.py
**Purpose:** Method overriding with default parameters
**Key Concepts:**
- Method overriding (`seating_capacity`)
- Default parameter values (`capacity=50`)
- Calling parent method with parameters

**Methods Used:**
- `seating_capacity(self, capacity=50)`
- `super().seating_capacity(capacity=capacity)`

### 05_class_property.py
**Purpose:** Class attributes vs instance attributes
**Key Concepts:**
- Class attribute definition (`color = "White"`)
- Shared attributes across all instances
- Multiple ways to access class attributes
- Inheritance of class attributes

**Access Methods:**
- `self.color` (from instance)
- `Bus.color` (from class name)

### 06_inheritance.py
**Purpose:** Method overriding with calculations
**Key Concepts:**
- Fare calculation in parent class
- Method overriding with additional logic
- Mathematical operations in methods
- Parent method calling and modification

**Calculations:**
- Base fare: `capacity * 100`
- Bus fare: `total_fare + (total_fare * .10)`

### 07_type_checking.py
**Purpose:** Object type identification
**Key Concepts:**
- `type()` function usage
- Determining exact class of object
- Object type verification

**Output:** `<class '__main__.Bus'>`

### 08_instance_inheritance.py
**Purpose:** Instance relationship verification
**Key Concepts:**
- `isinstance()` function usage
- Checking inheritance relationships
- Verifying if object belongs to parent class

**Result:** `True` (Bus instance is also Vehicle instance)

### 09_subclass_verification.py
**Purpose:** Class hierarchy verification
**Key Concepts:**
- `issubclass()` function usage
- Multi-level inheritance testing
- Class relationship verification

**Test Results:**
- `issubclass(Dog, Animal)` → True
- `issubclass(Animal, Dog)` → False
- `issubclass(Cat, Animal)` → False
- `issubclass(Puppy, Animal)` → True

### 10_shape_areas.py
**Purpose:** Abstract methods and polymorphism
**Key Concepts:**
- Abstract base class with `NotImplementedError`
- Method implementation in subclasses
- Polymorphism demonstration
- Mathematical calculations
- List iteration with different object types

**Mathematical Formulas:**
- Circle area: `π × r²`
- Square area: `side²`

================================================================================

## 8. PROGRAMMING PATTERNS AND BEST PRACTICES

### 8.1 Design Patterns Used

#### Template Method Pattern:
- `Shape` class defines interface
- Subclasses implement specific behavior

#### Inheritance Pattern:
- Base classes define common functionality
- Child classes extend or override behavior

#### Constructor Pattern:
- Consistent initialization across classes
- Parameter passing to parent constructors

### 8.2 Best Practices Demonstrated

#### Naming Conventions:
- **Classes:** PascalCase (`Vehicle`, `Bus`, `Circle`)
- **Methods:** snake_case (`max_speed`, `seating_capacity`)
- **Variables:** snake_case (`total_fare`, `final_amount`)
- **Constants:** UPPER_CASE (implied for class attributes)

#### Documentation:
- Docstrings for classes and methods
- Inline comments explaining functionality
- Multi-line comments for exercise descriptions

#### Code Organization:
- Logical class hierarchy
- Proper method grouping
- Clear separation of concerns

#### Error Handling:
- Abstract method implementation with `NotImplementedError`
- Meaningful error messages
- Proper exception raising

### 8.3 OOP Principles Applied

#### Encapsulation:
- Data and methods bundled in classes
- Controlled access through methods

#### Inheritance:
- Code reuse through parent-child relationships
- Method and attribute inheritance

#### Polymorphism:
- Same interface, different implementations
- Method overriding for specific behavior

#### Abstraction:
- Abstract base classes defining interfaces
- Implementation details hidden in subclasses

================================================================================

## 9. ADVANCED CONCEPTS AND USE CASES

### 9.1 Method Resolution Order (MRO)
**Concept:** Order in which Python searches for methods
**Relevance:** Important for multiple inheritance scenarios
**Example:** `Puppy -> Dog -> Animal -> object`

### 9.2 Class vs Instance Method Calls
**Class Method Call:** `Bus.color`
**Instance Method Call:** `bus.show()`
**Difference:** Class methods don't require instance

### 9.3 Constructor Overriding
**Pattern:** Child class constructor calls parent constructor
**Implementation:** `super().__init__(parameters)`
**Benefit:** Maintains parent initialization while adding child-specific setup

### 9.4 Method Signature Compatibility
**Concept:** Overridden methods can have different signatures
**Example:** `seating_capacity(self, capacity=50)` vs `seating_capacity(self, capacity)`

### 9.5 Abstract Base Classes
**Purpose:** Define contracts for subclasses
**Implementation:** Methods that raise `NotImplementedError`
**Benefit:** Ensures consistent interface across subclasses

================================================================================

## 10. COMMON PATTERNS AND IDIOMS

### 10.1 Initialization Pattern:
```python
def __init__(self, param1, param2):
    self.param1 = param1
    self.param2 = param2
```

### 10.2 Inheritance Pattern:
```python
class Child(Parent):
    def __init__(self, params):
        super().__init__(parent_params)
        # child-specific initialization
```

### 10.3 Method Override Pattern:
```python
def method(self):
    parent_result = super().method()
    # modify or extend parent result
    return modified_result
```

### 10.4 Abstract Method Pattern:
```python
def abstract_method(self):
    raise NotImplementedError("Subclasses must implement this method")
```

### 10.5 Polymorphism Pattern:
```python
objects = [Class1(), Class2(), Class3()]
for obj in objects:
    obj.common_method()  # Different implementations
```

================================================================================

## 11. TESTING AND VERIFICATION METHODS

### Type Checking Methods:
1. **type(obj)** - Exact type identification
2. **isinstance(obj, Class)** - Instance verification
3. **issubclass(Child, Parent)** - Inheritance verification

### Use Cases:
- **type()**: When you need exact class match
- **isinstance()**: When inheritance relationships matter
- **issubclass()**: When verifying class hierarchies

================================================================================

## 12. SUMMARY OF KEY TAKEAWAYS

### Essential OOP Concepts:
1. **Classes** are blueprints for objects
2. **Objects** are instances of classes
3. **Inheritance** enables code reuse and specialization
4. **Method overriding** allows customization of behavior
5. **Polymorphism** enables same interface, different implementations
6. **Abstraction** hides implementation details

### Critical Keywords:
- `class`, `def`, `self`, `super()`, `pass`
- `isinstance()`, `issubclass()`, `type()`
- `raise`, `return`, `import`

### Best Practices:
- Use meaningful names for classes and methods
- Document code with docstrings and comments
- Follow inheritance hierarchies logically
- Implement abstract methods in subclasses
- Use super() for parent class access
- Apply proper naming conventions

This comprehensive guide covers all methods, keywords, and use cases demonstrated in the OOP Exercise files, providing a complete reference for understanding object-oriented programming concepts in Python.