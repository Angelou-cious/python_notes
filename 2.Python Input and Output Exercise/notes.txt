PYTHON INPUT AND OUTPUT COMPREHENSIVE NOTES
===========================================

TABLE OF CONTENTS
-----------------
1. Input and Output Basics
2. Input Function and User Interaction
3. Print Function and Output Formatting
4. String Formatting Techniques
5. Number Formatting and Precision
6. Alignment and Padding
7. Separators and Delimiters
8. Number System Conversions
9. Interactive Programs and Menus
10. Data Collection and Processing
11. Error Handling in I/O Operations
12. Advanced Formatting Features
13. Built-in Functions for I/O
14. String Methods for I/O
15. Best Practices and Performance
16. Common Patterns and Use Cases

===============================

1. INPUT AND OUTPUT BASICS
===========================

Input/Output Definition:
- Input: Getting data from user or external sources
- Output: Displaying data to user or external destinations
- Essential for interactive programs and data processing
- Python provides built-in functions for I/O operations

Basic I/O Functions:
- input(): Get user input as string
- print(): Display output to console
- Both functions are fundamental to Python programming

Key Concepts:
- User interaction and feedback
- Data type conversion
- String manipulation
- Formatting and presentation
- Error handling and validation

Basic Syntax:
    # Input
    user_input = input("Enter something: ")
    
    # Output
    print("Hello, World!")
    print(variable_name)

Use Cases:
- Interactive applications
- Data collection
- User interfaces
- Debugging and testing
- Data presentation

===============================

2. INPUT FUNCTION AND USER INTERACTION
=======================================

input() Function:
- Always returns string data type
- Displays prompt message to user
- Waits for user to press Enter
- Can be converted to other data types

Basic Input Syntax:
    user_input = input("Prompt message: ")

Input with Type Conversion:
    # Integer input
    num1 = int(input("Enter first number: "))
    num2 = int(input("Enter second number: "))
    
    # Float input
    price = float(input("Enter price: "))
    
    # String input (default)
    name = input("Enter your name: ")

Multiple Inputs in One Line:
    names = input("Enter three names separated by space: ")
    name1, name2, name3 = names.split()

Input with F-strings:
    num1 = int(input(f'Enter first number: '))
    num2 = int(input(f'Enter second number: '))

Collecting Multiple Values:
    numbers = []
    for i in range(5):
        num = float(input(f'Input number {i+1}: '))
        numbers.append(num)

Input Validation Patterns:
    # Basic validation
    while True:
        try:
            number = int(input("Enter a number: "))
            break
        except ValueError:
            print("Invalid input. Please enter a number.")

Interactive Menu Example:
    while True:
        try:
            choice = int(input("1. Say Hello, 2. Calculate Square, 3. Exit: "))
            
            if choice == 3:
                break
            elif choice == 2:
                number = int(input("Enter number: "))
                square = number ** 2
                print(f"Square of {number} is {square}")
            elif choice == 1:
                print("Hello!")
        except ValueError:
            print("Invalid input")

Use Cases:
- User data collection
- Interactive applications
- Configuration input
- Menu-driven programs
- Data entry systems

===============================

3. PRINT FUNCTION AND OUTPUT FORMATTING
========================================

print() Function:
- Displays output to console
- Accepts multiple arguments
- Supports various formatting options
- Can control output behavior

Basic Print Syntax:
    print("Hello, World!")
    print(variable)
    print("Text", variable, "more text")

Print with Multiple Arguments:
    str1 = 'My'
    str2 = 'Name'
    str3 = 'Is'
    str4 = 'James'
    print(str1, str2, str3, str4)

Print Parameters:

sep Parameter:
- Controls separator between arguments
- Default is single space
    print(str1, str2, str3, str4, sep='**')
    # Output: My**Name**Is**James

end Parameter:
- Controls what prints at the end
- Default is newline (\n)
    print("Hello", end=' ')
    print("World")  # Output: Hello World

file Parameter:
- Redirect output to file
    with open('output.txt', 'w') as f:
        print("Hello", file=f)

flush Parameter:
- Force immediate output
    print("Loading...", end='', flush=True)

Print with Variables:
    name = "Alice"
    age = 25
    print("Name:", name, "Age:", age)

Use Cases:
- Displaying results
- Debugging information
- User feedback
- Data presentation
- Progress indicators

===============================

4. STRING FORMATTING TECHNIQUES
================================

F-string Formatting (Python 3.6+):
- Most modern and readable approach
- Embed expressions directly in strings
- Support for format specifications

F-string Syntax:
    name = "Alice"
    age = 25
    print(f"Hello {name}, you are {age} years old")

F-string with Expressions:
    num1 = 10
    num2 = 20
    print(f"The sum is {num1 + num2}")

F-string with Formatting:
    price = 19.99
    print(f"Price: ${price:.2f}")

.format() Method:
- Older but still widely used
- Positional and keyword arguments
- Flexible formatting options

Format Method Syntax:
    totalMoney = 1000
    quantity = 3
    price = 450
    print('I have {0} dollars so I can buy {1} football for {2:.2f} dollars.'.format(totalMoney, quantity, price))

Format with Named Arguments:
    print("Hello {name}, you are {age} years old".format(name="Bob", age=30))

% Formatting (Old Style):
- Legacy formatting method
- Still used in some contexts
- Similar to C printf

Percent Formatting Syntax:
    name = "Charlie"
    age = 35
    print("Hello %s, you are %d years old" % (name, age))

Comparison of Methods:
    name = "David"
    score = 95.5
    
    # F-string (recommended)
    print(f"Student: {name}, Score: {score:.1f}")
    
    # .format() method
    print("Student: {}, Score: {:.1f}".format(name, score))
    
    # % formatting
    print("Student: %s, Score: %.1f" % (name, score))

Use Cases:
- Dynamic text generation
- Report formatting
- Template processing
- Data presentation
- User interface text

===============================

5. NUMBER FORMATTING AND PRECISION
===================================

Decimal Precision:
- Control number of decimal places
- Rounding behavior
- Scientific notation

Float Precision with F-strings:
    num = 458.541315
    print(f'{num:.2f}')  # 458.54
    print(f'{num:.3f}')  # 458.541

Float Precision with % Formatting:
    num = 458.541315
    print('%.3f' % num)  # 458.541

Percentage Formatting:
    numerator = 75
    denominator = 100
    percentage = (numerator / denominator) * 100
    print(f'{percentage:.2f}%')  # 75.00%

Scientific Notation:
    large_number = 1234567890
    print(f'{large_number:.2e}')  # 1.23e+09

Number Padding and Alignment:
    number = 42
    print(f'{number:05d}')    # 00042 (zero-padded)
    print(f'{number:>10d}')   # "        42" (right-aligned)
    print(f'{number:<10d}')   # "42        " (left-aligned)
    print(f'{number:^10d}')   # "    42    " (center-aligned)

Leading Zeros with zfill():
    number = input("Enter a number: ")
    padded_number = number.zfill(5)
    print(padded_number)  # "123" becomes "00123"

Currency Formatting:
    price = 1234.56
    print(f'${price:,.2f}')  # $1,234.56

Binary, Octal, Hexadecimal:
    num = 255
    print(f'Binary: {num:b}')      # 11111111
    print(f'Octal: {num:o}')       # 377
    print(f'Hexadecimal: {num:x}') # ff
    print(f'Hexadecimal: {num:X}') # FF

Legacy Number System Formatting:
    num = 8
    print('%o' % num)  # 10 (octal)
    print('%d' % num)  # 8 (decimal)
    print('%x' % num)  # 8 (hexadecimal)

Use Cases:
- Financial calculations
- Scientific data presentation
- Progress indicators
- Data analysis reports
- User-friendly number display

===============================

6. ALIGNMENT AND PADDING
=========================

Text Alignment:
- Control text positioning within specified width
- Left, right, and center alignment
- Padding with spaces or custom characters

Alignment Syntax:
    word = "Python"
    number = 42
    
    # Default (right-aligned for numbers, left for strings)
    print(f'|{word:10}|')      # |Python    |
    print(f'|{number:10}|')    # |        42|
    
    # Explicit right alignment
    print(f'|{word:>10}|')     # |    Python|
    
    # Left alignment
    print(f'|{word:<10}|')     # |Python    |
    
    # Center alignment
    print(f'|{word:^10}|')     # |  Python  |

Padding with Custom Characters:
    text = "Hello"
    print(f'{text:*^15}')      # *****Hello*****
    print(f'{text:->15}')      # ----------Hello
    print(f'{text:=<15}')      # Hello==========

Number Padding:
    number = 123
    print(f'{number:08d}')     # 00000123
    print(f'{number:+08d}')    # +0000123
    print(f'{number: 08d}')    # 0000123 (space for positive)

Tabular Display:
    def display_table(names, scores):
        print(f"{'Name':<20} {'Score'}")
        print("-" * 30)
        
        for name, score in zip(names, scores):
            print(f'{name:<20} {score}')
    
    names = ["Alice", "Bob", "Charlie"]
    scores = [85, 92, 78]
    display_table(names, scores)

Column Alignment:
    data = [
        ("Product", "Price", "Quantity"),
        ("Apple", 1.50, 10),
        ("Banana", 0.75, 25),
        ("Orange", 2.00, 8)
    ]
    
    for row in data:
        print(f'{row[0]:<10} ${row[1]:>6.2f} {row[2]:>8}')

Use Cases:
- Table formatting
- Report generation
- Data presentation
- User interface alignment
- Log file formatting

===============================

7. SEPARATORS AND DELIMITERS
=============================

Print Separators:
- Control how multiple print arguments are separated
- Default separator is single space
- Custom separators for specific formatting

Custom Separators:
    # Default separator (space)
    print("A", "B", "C")           # A B C
    
    # Custom separator
    print("A", "B", "C", sep="-")  # A-B-C
    print("A", "B", "C", sep="**") # A**B**C
    print("A", "B", "C", sep="")   # ABC

Line Endings:
    # Default end (newline)
    print("Line 1")
    print("Line 2")
    
    # Custom end
    print("Same ", end="")
    print("line")                  # Same line
    
    # Multiple items on same line
    for i in range(5):
        print(i, end=" ")          # 0 1 2 3 4
    print()  # New line at end

Input String Splitting:
    # Split input by spaces
    names = input("Enter names separated by spaces: ")
    name_list = names.split()
    
    # Split by custom delimiter
    data = input("Enter data separated by commas: ")
    data_list = data.split(",")

Joining Strings:
    words = ["Python", "is", "awesome"]
    sentence = " ".join(words)     # "Python is awesome"
    csv_line = ",".join(words)     # "Python,is,awesome"

File Path Separators:
    import os
    path_parts = ["home", "user", "documents", "file.txt"]
    full_path = os.path.join(*path_parts)

Use Cases:
- CSV data processing
- Custom formatting
- Data parsing
- File path construction
- Configuration files

===============================

8. NUMBER SYSTEM CONVERSIONS
=============================

Binary, Octal, Hexadecimal Display:
- Convert numbers to different bases
- Useful for programming and debugging
- Multiple formatting approaches

Modern Formatting (F-strings):
    number = 255
    print(f'Decimal: {number}')
    print(f'Binary: {number:b}')
    print(f'Octal: {number:o}')
    print(f'Hexadecimal: {number:x}')
    print(f'Hexadecimal (uppercase): {number:X}')

Legacy Formatting (% operator):
    num = 8
    print('%d' % num)  # Decimal: 8
    print('%o' % num)  # Octal: 10
    print('%x' % num)  # Hexadecimal: 8

With Prefixes:
    number = 255
    print(f'Binary: 0b{number:b}')      # 0b11111111
    print(f'Octal: 0o{number:o}')       # 0o377
    print(f'Hexadecimal: 0x{number:x}') # 0xff

Conversion Functions:
    # String to different bases
    decimal_str = "255"
    decimal_num = int(decimal_str)
    
    binary_str = "11111111"
    from_binary = int(binary_str, 2)    # 255
    
    hex_str = "FF"
    from_hex = int(hex_str, 16)         # 255
    
    octal_str = "377"
    from_octal = int(octal_str, 8)      # 255

Formatted Number Systems:
    def display_number_systems(num):
        print(f"Number: {num}")
        print(f"Binary:      {num:>10b}")
        print(f"Octal:       {num:>10o}")
        print(f"Decimal:     {num:>10d}")
        print(f"Hexadecimal: {num:>10x}")

User Input for Different Bases:
    # Get binary input
    binary_input = input("Enter binary number: ")
    decimal_value = int(binary_input, 2)
    print(f"Decimal equivalent: {decimal_value}")

Use Cases:
- Programming education
- Debugging binary operations
- Network programming
- System programming
- Data analysis

===============================

9. INTERACTIVE PROGRAMS AND MENUS
==================================

Menu-Driven Programs:
- Present options to users
- Handle user choices
- Loop until exit condition
- Error handling for invalid input

Basic Menu Structure:
    while True:
        print("\n=== MENU ===")
        print("1. Option 1")
        print("2. Option 2")
        print("3. Exit")
        
        try:
            choice = int(input("Enter your choice: "))
            
            if choice == 1:
                print("You selected Option 1")
            elif choice == 2:
                print("You selected Option 2")
            elif choice == 3:
                print("Goodbye!")
                break
            else:
                print("Invalid choice")
        except ValueError:
            print("Please enter a valid number")

Advanced Menu Example:
    def calculator_menu():
        while True:
            try:
                print("\n=== CALCULATOR ===")
                choice = int(input("1. Say Hello, 2. Calculate Square, 3. Exit: "))
                
                if choice == 3:
                    break
                elif choice == 2:
                    try:
                        number = int(input("Enter number: "))
                        square = number ** 2
                        print(f"The square of {number} is {square}")
                    except ValueError:
                        print("Invalid input")
                elif choice == 1:
                    print("Hello!")
                else:
                    print("Invalid choice")
            except ValueError:
                print("Invalid Number")

Input Validation Patterns:
    def get_valid_integer(prompt):
        while True:
            try:
                return int(input(prompt))
            except ValueError:
                print("Please enter a valid integer")
    
    def get_valid_float(prompt):
        while True:
            try:
                return float(input(prompt))
            except ValueError:
                print("Please enter a valid number")

Confirmation Prompts:
    def confirm_action(message):
        while True:
            response = input(f"{message} (y/n): ").lower()
            if response in ['y', 'yes']:
                return True
            elif response in ['n', 'no']:
                return False
            else:
                print("Please enter 'y' or 'n'")

Progress Indicators:
    import time
    
    def show_progress():
        for i in range(101):
            print(f"\rProgress: {i}%", end="", flush=True)
            time.sleep(0.01)
        print("\nComplete!")

Use Cases:
- Command-line applications
- Configuration utilities
- Data entry systems
- Educational programs
- System administration tools

===============================

10. DATA COLLECTION AND PROCESSING
===================================

Collecting Multiple Inputs:
- Gather data from users
- Store in appropriate data structures
- Process and validate input
- Display results

List Collection:
    numbers = []
    count = int(input("How many numbers? "))
    
    for i in range(count):
        num = float(input(f'Enter number {i+1}: '))
        numbers.append(num)
    
    print(f"Numbers entered: {numbers}")
    print(f"Sum: {sum(numbers)}")
    print(f"Average: {sum(numbers)/len(numbers):.2f}")

Dictionary Collection:
    students = {}
    
    while True:
        name = input("Enter student name (or 'quit'): ")
        if name.lower() == 'quit':
            break
        
        try:
            grade = float(input(f"Enter grade for {name}: "))
            students[name] = grade
        except ValueError:
            print("Invalid grade entered")
    
    # Display results
    for name, grade in students.items():
        print(f"{name}: {grade}")

Batch Data Entry:
    def collect_employee_data():
        employees = []
        
        while True:
            print("\n--- Employee Entry ---")
            name = input("Name (or 'done'): ")
            if name.lower() == 'done':
                break
            
            try:
                age = int(input("Age: "))
                salary = float(input("Salary: "))
                
                employee = {
                    'name': name,
                    'age': age,
                    'salary': salary
                }
                employees.append(employee)
                
            except ValueError:
                print("Invalid input, skipping entry")
        
        return employees

CSV-like Data Input:
    def parse_csv_input():
        data = []
        print("Enter data in format: name,age,city (or 'done')")
        
        while True:
            line = input("Data: ")
            if line.lower() == 'done':
                break
            
            try:
                parts = line.split(',')
                if len(parts) == 3:
                    name, age, city = parts
                    data.append({
                        'name': name.strip(),
                        'age': int(age.strip()),
                        'city': city.strip()
                    })
                else:
                    print("Invalid format")
            except ValueError:
                print("Invalid age value")
        
        return data

File-like Input Processing:
    def process_input_lines():
        lines = []
        print("Enter lines of text (empty line to finish):")
        
        while True:
            line = input()
            if not line:
                break
            lines.append(line)
        
        # Process lines
        word_count = sum(len(line.split()) for line in lines)
        char_count = sum(len(line) for line in lines)
        
        print(f"Lines: {len(lines)}")
        print(f"Words: {word_count}")
        print(f"Characters: {char_count}")

Use Cases:
- Data entry applications
- Survey collection
- Configuration setup
- Batch processing
- Data migration tools

===============================

11. ERROR HANDLING IN I/O OPERATIONS
=====================================

Input Validation:
- Handle invalid user input
- Provide meaningful error messages
- Allow users to retry
- Prevent program crashes

Basic Try-Except for Input:
    try:
        number = int(input("Enter a number: "))
        print(f"You entered: {number}")
    except ValueError:
        print("That's not a valid number!")

Robust Input Function:
    def get_integer_input(prompt, min_val=None, max_val=None):
        while True:
            try:
                value = int(input(prompt))
                
                if min_val is not None and value < min_val:
                    print(f"Value must be at least {min_val}")
                    continue
                
                if max_val is not None and value > max_val:
                    print(f"Value must be at most {max_val}")
                    continue
                
                return value
                
            except ValueError:
                print("Please enter a valid integer")

Multiple Exception Types:
    def safe_calculation():
        try:
            num1 = float(input("Enter first number: "))
            num2 = float(input("Enter second number: "))
            operation = input("Enter operation (+, -, *, /): ")
            
            if operation == '+':
                result = num1 + num2
            elif operation == '-':
                result = num1 - num2
            elif operation == '*':
                result = num1 * num2
            elif operation == '/':
                result = num1 / num2
            else:
                print("Invalid operation")
                return
            
            print(f"Result: {result}")
            
        except ValueError:
            print("Invalid number entered")
        except ZeroDivisionError:
            print("Cannot divide by zero")
        except Exception as e:
            print(f"An error occurred: {e}")

Input Retry Mechanism:
    def get_valid_email():
        max_attempts = 3
        attempts = 0
        
        while attempts < max_attempts:
            email = input("Enter email address: ")
            
            if '@' in email and '.' in email:
                return email
            else:
                attempts += 1
                remaining = max_attempts - attempts
                if remaining > 0:
                    print(f"Invalid email. {remaining} attempts remaining.")
                else:
                    print("Maximum attempts reached.")
                    return None

File I/O Error Handling:
    def safe_file_output(filename, data):
        try:
            with open(filename, 'w') as file:
                print(data, file=file)
            print(f"Data saved to {filename}")
        except PermissionError:
            print("Permission denied to write file")
        except IOError:
            print("Error writing to file")

Use Cases:
- User input validation
- Robust applications
- Data integrity
- User experience improvement
- System reliability

===============================

12. ADVANCED FORMATTING FEATURES
=================================

Format Specifications:
- Detailed control over output appearance
- Width, precision, alignment, and type
- Custom formatting for different data types

Format Specification Syntax:
    # General format: {value:[[fill]align][sign][#][0][width][,][.precision][type]}
    
    number = 1234.5678
    
    # Width and precision
    print(f"{number:10.2f}")      # "   1234.57"
    
    # Fill character and alignment
    print(f"{number:*>15.2f}")    # "****1234.57"
    print(f"{number:0<15.2f}")    # "1234.570000000"
    print(f"{number:^15.2f}")     # "   1234.57    "

Sign Control:
    positive = 42
    negative = -42
    
    print(f"{positive:+}")        # +42
    print(f"{negative:+}")        # -42
    print(f"{positive: }")        # " 42" (space for positive)

Thousands Separator:
    large_number = 1234567
    print(f"{large_number:,}")    # 1,234,567
    print(f"{large_number:_}")    # 1_234_567

Type Specifiers:
    value = 42
    
    print(f"{value:d}")           # 42 (decimal)
    print(f"{value:b}")           # 101010 (binary)
    print(f"{value:o}")           # 52 (octal)
    print(f"{value:x}")           # 2a (hexadecimal)
    print(f"{value:c}")           # * (character)

String Formatting:
    text = "Python"
    
    print(f"{text:>10}")          # "    Python"
    print(f"{text:<10}")          # "Python    "
    print(f"{text:^10}")          # "  Python  "
    print(f"{text:.3}")           # "Pyt" (truncate)

Date and Time Formatting:
    from datetime import datetime
    
    now = datetime.now()
    print(f"{now:%Y-%m-%d %H:%M:%S}")     # 2023-12-25 14:30:45
    print(f"{now:%B %d, %Y}")             # December 25, 2023

Custom Format Classes:
    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y
        
        def __format__(self, format_spec):
            if format_spec == 'p':
                return f"({self.x}, {self.y})"
            elif format_spec == 'c':
                return f"{self.x} + {self.y}i"
            else:
                return f"Point({self.x}, {self.y})"
    
    p = Point(3, 4)
    print(f"{p:p}")               # (3, 4)
    print(f"{p:c}")               # 3 + 4i

Use Cases:
- Report generation
- Data presentation
- Financial applications
- Scientific computing
- User interface formatting

===============================

13. BUILT-IN FUNCTIONS FOR I/O
===============================

Core I/O Functions:

input():
- Get user input as string
- Display optional prompt
- Always returns string type

    user_input = input()                    # No prompt
    name = input("Enter your name: ")       # With prompt

print():
- Display output to console
- Multiple arguments supported
- Customizable separators and endings

    print("Hello")                          # Simple output
    print("A", "B", "C")                   # Multiple arguments
    print("Hello", end="")                 # No newline
    print("A", "B", sep="-")               # Custom separator

Type Conversion Functions:

int():
- Convert to integer
- Specify base for number systems

    number = int(input("Enter number: "))
    binary_num = int("1010", 2)            # Binary to decimal

float():
- Convert to floating-point number

    price = float(input("Enter price: "))

str():
- Convert to string
- Default for input() function

    text = str(123)                        # "123"

String Processing Functions:

split():
- Split string into list
- Default splits on whitespace

    names = input("Enter names: ").split()
    data = input("CSV data: ").split(",")

join():
- Join list elements into string

    words = ["Hello", "World"]
    sentence = " ".join(words)             # "Hello World"

strip():
- Remove whitespace from ends

    clean_input = input("Enter text: ").strip()

Formatting Functions:

format():
- Format values with specifications

    result = format(123.456, ".2f")        # "123.46"

zfill():
- Pad with leading zeros

    number = "123"
    padded = number.zfill(5)               # "00123"

Mathematical Functions:

round():
- Round to specified decimal places

    rounded = round(3.14159, 2)            # 3.14

abs():
- Absolute value

    positive = abs(-42)                    # 42

Use Cases:
- Data conversion
- Input processing
- Output formatting
- String manipulation
- Mathematical operations

===============================

14. STRING METHODS FOR I/O
===========================

String Input Processing:

strip(), lstrip(), rstrip():
- Remove whitespace or specified characters

    user_input = input("Enter text: ").strip()
    left_clean = text.lstrip()
    right_clean = text.rstrip()
    custom_strip = text.strip(".,!?")

split() and rsplit():
- Split strings into lists

    # Split on whitespace
    words = sentence.split()
    
    # Split on custom delimiter
    parts = data.split(",")
    
    # Limit splits
    first_two = text.split(" ", 1)
    
    # Split from right
    extension = filename.rsplit(".", 1)

join():
- Combine list elements

    # Join with space
    sentence = " ".join(word_list)
    
    # Join with custom separator
    csv_line = ",".join(data_list)
    
    # Join with no separator
    combined = "".join(char_list)

Case Methods:
- Control text case

    text = input("Enter text: ")
    print(text.upper())                    # UPPERCASE
    print(text.lower())                    # lowercase
    print(text.title())                    # Title Case
    print(text.capitalize())               # Capitalize first

String Validation:
- Check string properties

    user_input = input("Enter data: ")
    
    if user_input.isdigit():
        print("All digits")
    elif user_input.isalpha():
        print("All letters")
    elif user_input.isalnum():
        print("Letters and digits")

String Searching:
- Find substrings

    text = input("Enter text: ")
    
    if "python" in text.lower():
        print("Contains 'python'")
    
    position = text.find("keyword")
    if position != -1:
        print(f"Found at position {position}")

String Replacement:
- Replace substrings

    text = input("Enter text: ")
    cleaned = text.replace("  ", " ")      # Remove double spaces
    corrected = text.replace("teh", "the") # Fix typos

Padding and Alignment:
- Format string width

    text = "Python"
    print(text.center(20))                 # Center in 20 chars
    print(text.ljust(20))                  # Left justify
    print(text.rjust(20))                  # Right justify
    print(text.zfill(10))                  # Zero pad

Use Cases:
- Input cleaning
- Data validation
- Text processing
- Format standardization
- User input normalization

===============================

15. BEST PRACTICES AND PERFORMANCE
===================================

Input Validation Best Practices:

Always Validate User Input:
    def get_positive_integer(prompt):
        while True:
            try:
                value = int(input(prompt))
                if value > 0:
                    return value
                else:
                    print("Please enter a positive number")
            except ValueError:
                print("Please enter a valid integer")

Provide Clear Error Messages:
    try:
        age = int(input("Enter your age: "))
    except ValueError:
        print("Error: Age must be a whole number (e.g., 25)")

Use Appropriate Data Types:
    # Good: Convert immediately
    count = int(input("How many items? "))
    
    # Avoid: Keep as string when number needed
    count_str = input("How many items? ")
    # ... later convert when needed

Output Formatting Best Practices:

Use F-strings for Modern Python:
    # Preferred (Python 3.6+)
    name = "Alice"
    age = 25
    print(f"Hello {name}, you are {age} years old")
    
    # Older methods (still valid)
    print("Hello {}, you are {} years old".format(name, age))
    print("Hello %s, you are %d years old" % (name, age))

Consistent Formatting:
    # Good: Consistent decimal places
    prices = [19.99, 5.00, 123.45]
    for price in prices:
        print(f"${price:.2f}")
    
    # Avoid: Inconsistent formatting
    print(f"${prices[0]}")      # $19.99
    print(f"${prices[1]:.1f}")  # $5.0

Performance Considerations:

Minimize I/O Operations:
    # Inefficient: Multiple print calls
    for i in range(1000):
        print(i)
    
    # Better: Batch output
    output = []
    for i in range(1000):
        output.append(str(i))
    print('\n'.join(output))

Use Appropriate Buffer Sizes:
    # For large outputs, consider buffering
    import sys
    
    # Force immediate output when needed
    print("Processing...", end="", flush=True)

Memory Efficiency:
    # For large datasets, process incrementally
    def process_large_input():
        while True:
            line = input("Enter data (or 'done'): ")
            if line == 'done':
                break
            process_line(line)  # Process immediately
            # Don't store all in memory

Error Handling Best Practices:

Graceful Degradation:
    def safe_input_with_default(prompt, default, converter=str):
        try:
            user_input = input(prompt)
            if not user_input.strip():
                return default
            return converter(user_input)
        except (ValueError, KeyboardInterrupt):
            return default

Specific Exception Handling:
    try:
        value = float(input("Enter number: "))
    except ValueError:
        print("Invalid number format")
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
    except EOFError:
        print("\nUnexpected end of input")

Use Cases:
- Production applications
- User-friendly interfaces
- Robust data processing
- Performance-critical systems
- Maintainable code

===============================

16. COMMON PATTERNS AND USE CASES
==================================

Data Entry Patterns:

Single Value Input:
    def get_user_info():
        name = input("Enter your name: ").strip()
        age = int(input("Enter your age: "))
        email = input("Enter your email: ").strip().lower()
        return {'name': name, 'age': age, 'email': email}

Multiple Choice Input:
    def get_menu_choice():
        options = {
            '1': 'Create new record',
            '2': 'View records',
            '3': 'Delete record',
            '4': 'Exit'
        }
        
        while True:
            print("\nMenu Options:")
            for key, value in options.items():
                print(f"{key}. {value}")
            
            choice = input("Select option: ").strip()
            if choice in options:
                return choice
            print("Invalid choice. Please try again.")

Batch Data Collection:
    def collect_survey_responses():
        responses = []
        
        print("Survey: Rate from 1-5 (or 'done' to finish)")
        while True:
            response = input("Rating: ").strip()
            if response.lower() == 'done':
                break
            
            try:
                rating = int(response)
                if 1 <= rating <= 5:
                    responses.append(rating)
                else:
                    print("Rating must be between 1 and 5")
            except ValueError:
                print("Please enter a number")
        
        return responses

Report Generation Patterns:

Simple Report:
    def generate_summary_report(data):
        print("=" * 50)
        print("SUMMARY REPORT".center(50))
        print("=" * 50)
        
        for key, value in data.items():
            print(f"{key:<20}: {value}")
        
        print("=" * 50)

Tabular Report:
    def display_student_grades(students):
        print(f"{'Name':<15} {'Grade':<8} {'Status':<10}")
        print("-" * 35)
        
        for student in students:
            status = "Pass" if student['grade'] >= 60 else "Fail"
            print(f"{student['name']:<15} {student['grade']:<8} {status:<10}")

Progress Indication:
    def show_processing_progress(items):
        total = len(items)
        for i, item in enumerate(items, 1):
            # Process item
            process_item(item)
            
            # Show progress
            percent = (i / total) * 100
            print(f"\rProgress: {percent:.1f}% ({i}/{total})", end="", flush=True)
        
        print("\nProcessing complete!")

Configuration Patterns:

Settings Input:
    def get_application_settings():
        settings = {}
        
        # Get various configuration options
        settings['debug'] = input("Enable debug mode? (y/n): ").lower() == 'y'
        settings['max_connections'] = int(input("Max connections (default 100): ") or "100")
        settings['timeout'] = float(input("Timeout in seconds (default 30.0): ") or "30.0")
        
        return settings

File Path Input:
    def get_file_paths():
        import os
        
        while True:
            path = input("Enter file path: ").strip()
            if os.path.exists(path):
                return path
            else:
                print("File not found. Please try again.")

Interactive Calculator:
    def calculator():
        print("Simple Calculator (type 'quit' to exit)")
        
        while True:
            try:
                expression = input("Enter calculation: ").strip()
                if expression.lower() == 'quit':
                    break
                
                # Simple evaluation (be careful with eval in production!)
                result = eval(expression)
                print(f"Result: {result}")
                
            except Exception as e:
                print(f"Error: {e}")

Data Validation Patterns:

Email Validation:
    def get_valid_email():
        import re
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        
        while True:
            email = input("Enter email address: ").strip()
            if re.match(email_pattern, email):
                return email
            print("Invalid email format. Please try again.")

Phone Number Validation:
    def get_phone_number():
        import re
        
        while True:
            phone = input("Enter phone number (XXX-XXX-XXXX): ").strip()
            if re.match(r'^\d{3}-\d{3}-\d{4}$', phone):
                return phone
            print("Invalid format. Use XXX-XXX-XXXX")

Use Cases:
- Command-line applications
- Data collection systems
- Configuration utilities
- Interactive tutorials
- System administration tools
- User registration systems
- Survey applications
- Calculator programs

===============================

SUMMARY OF I/O CONCEPTS
========================

Input Functions:
- input()               # Get user input as string
- int(input())          # Convert input to integer
- float(input())        # Convert input to float
- input().split()       # Split input into list

Output Functions:
- print()               # Display output
- print(sep="")         # Custom separator
- print(end="")         # Custom line ending
- print(file=f)         # Output to file

Formatting Methods:
- f"text {var}"         # F-string formatting (modern)
- "text {}".format()    # Format method
- "text %s" % var       # Percent formatting (legacy)

Format Specifications:
- {var:.2f}             # Float with 2 decimal places
- {var:>10}             # Right align in 10 characters
- {var:<10}             # Left align in 10 characters
- {var:^10}             # Center align in 10 characters
- {var:05d}             # Zero-pad integer to 5 digits

String Methods:
- .strip()              # Remove whitespace
- .split()              # Split into list
- .join()               # Join list elements
- .zfill()              # Zero-fill padding
- .upper()/.lower()     # Case conversion

Number Systems:
- {num:b}               # Binary representation
- {num:o}               # Octal representation
- {num:x}               # Hexadecimal representation
- {num:d}               # Decimal representation

Error Handling:
- try/except            # Handle input errors
- ValueError            # Invalid type conversion
- KeyboardInterrupt     # User cancellation
- EOFError              # End of input

Common Patterns:
- Input validation      # Ensure valid data
- Menu systems          # User choice handling
- Data collection       # Gather multiple inputs
- Report generation     # Format output nicely
- Progress indication   # Show processing status

===============================

This comprehensive guide covers all input/output concepts, methods, and techniques demonstrated in the Python Input and Output Exercise files. Each concept includes syntax, examples, and practical applications for effective I/O programming in various scenarios.