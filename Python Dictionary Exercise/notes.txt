PYTHON DICTIONARY COMPREHENSIVE NOTES
=====================================

TABLE OF CONTENTS
==================
1. Dictionary Basics
2. Dictionary Creation Methods
3. Dictionary Access Methods
4. Dictionary Modification Methods
5. Dictionary Removal Methods
6. Dictionary Iteration Methods
7. Dictionary Utility Methods
8. Dictionary Comprehensions
9. Nested Dictionary Operations
10. Dictionary Sorting
11. Dictionary Merging
12. Built-in Functions with Dictionaries
13. Best Practices and Common Patterns
14. Error Handling and Safety

=====================================

1. DICTIONARY BASICS
====================

Definition:
- Dictionaries are mutable, unordered collections of key-value pairs
- Keys must be immutable (strings, numbers, tuples)
- Values can be any data type
- Since Python 3.7+, dictionaries maintain insertion order

Syntax:
```python
# Empty dictionary
empty_dict = {}
empty_dict = dict()

# Dictionary with initial values
my_dict = {'key1': 'value1', 'key2': 'value2'}
```

=====================================

2. DICTIONARY CREATION METHODS
===============================

2.1 Literal Creation
```python
my_dict = {'name': 'Alice', 'age': 35, 'city': 'New York'}
```

2.2 dict() Constructor
```python
my_dict = dict(name='Alice', age=35, city='New York')
```

2.3 From Lists using zip()
```python
keys = ['Ten', 'Twenty', 'Thirty']
values = [10, 20, 30]
new_dict = {}
for key, value in zip(keys, values):
    new_dict[key] = value
```

2.4 dict.fromkeys() - Initialize with Default Values
```python
employees = ['Kelly', 'Emma', 'John']
defaults = {"designation": 'Developer', "salary": 8000}
res = dict.fromkeys(employees, defaults)
# Creates: {'Kelly': defaults, 'Emma': defaults, 'John': defaults}
```

2.5 Dictionary Comprehension
```python
# Extract specific keys
keys = ["name", "salary"]
newDict = {k: sampleDict[k] for k in keys}
```

=====================================

3. DICTIONARY ACCESS METHODS
=============================

3.1 Square Bracket Notation
```python
value = my_dict['key']  # Raises KeyError if key doesn't exist
```

3.2 get() Method - Safe Access
```python
value = my_dict.get('key')          # Returns None if key doesn't exist
value = my_dict.get('key', default) # Returns default if key doesn't exist

# Use case: Character frequency counting
frequency_dict[char] = frequency_dict.get(char, 0) + 1
```

3.3 Nested Dictionary Access
```python
# Direct access (can raise KeyError)
age = data['person']['age']

# Safe nested access pattern
try:
    age = data['person']['age']
except KeyError:
    age = None
```

=====================================

4. DICTIONARY MODIFICATION METHODS
===================================

4.1 Adding/Updating Values
```python
my_dict['new_key'] = 'new_value'    # Add new key-value pair
my_dict['existing_key'] = 'updated' # Update existing value
```

4.2 update() Method
```python
my_dict.update({'key1': 'value1', 'key2': 'value2'})
my_dict.update(key1='value1', key2='value2')
```

4.3 setdefault() Method
```python
# Sets key to value only if key doesn't exist
my_dict.setdefault('key', 'default_value')
```

=====================================

5. DICTIONARY REMOVAL METHODS
==============================

5.1 del Statement
```python
del my_dict['key']  # Removes key-value pair, raises KeyError if key doesn't exist
```

5.2 pop() Method
```python
value = my_dict.pop('key')           # Returns value and removes key
value = my_dict.pop('key', default)  # Returns default if key doesn't exist

# Use case: Renaming keys
sample_dict['location'] = sample_dict.pop('city')
```

5.3 popitem() Method
```python
key, value = my_dict.popitem()  # Removes and returns last inserted key-value pair
```

5.4 clear() Method
```python
my_dict.clear()  # Removes all key-value pairs, leaves empty dictionary
```

=====================================

6. DICTIONARY ITERATION METHODS
================================

6.1 keys() Method
```python
for key in my_dict.keys():
    print(key)

# Direct iteration (equivalent)
for key in my_dict:
    print(key)
```

6.2 values() Method
```python
for value in my_dict.values():
    print(value)

# Use case: Check if value exists
if 200 in my_dict.values():
    print("Value found")
```

6.3 items() Method
```python
for key, value in my_dict.items():
    print(f"{key}: {value}")

# Use case: Dictionary inversion
inverted = {value: key for key, value in original.items()}
```

=====================================

7. DICTIONARY UTILITY METHODS
==============================

7.1 len() Function
```python
count = len(my_dict)  # Returns number of key-value pairs
```

7.2 in Operator - Key Existence Check
```python
if 'key' in my_dict:
    print("Key exists")

if 'key' not in my_dict:
    print("Key doesn't exist")
```

7.3 copy() Method
```python
new_dict = my_dict.copy()  # Creates shallow copy
```

=====================================

8. DICTIONARY COMPREHENSIONS
=============================

8.1 Basic Comprehension
```python
# Square numbers
squares = {x: x**2 for x in range(5)}
# Result: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

8.2 Conditional Comprehension
```python
# Filter even keys
even_dict = {k: v for k, v in my_dict.items() if k % 2 == 0}
```

8.3 Key Extraction
```python
keys = ["name", "salary"]
extracted = {k: original_dict[k] for k in keys}
```

=====================================

9. NESTED DICTIONARY OPERATIONS
================================

9.1 Creating Nested Dictionaries
```python
nested_dict = {
    'person': {
        'name': 'Alice',
        'age': 30,
        'address': {
            'city': 'New York',
            'zip': '10001'
        }
    }
}
```

9.2 Accessing Nested Values
```python
# Direct access
name = nested_dict['person']['name']
city = nested_dict['person']['address']['city']
```

9.3 Modifying Nested Values
```python
nested_dict['person']['age'] = 31
nested_dict['person']['address']['city'] = 'Boston'
```

9.4 Safe Nested Access Pattern
```python
def safe_get_nested(dictionary, *keys):
    for key in keys:
        try:
            dictionary = dictionary[key]
        except (KeyError, TypeError):
            return None
    return dictionary

# Usage
age = safe_get_nested(data, 'person', 'age')
```

=====================================

10. DICTIONARY SORTING
=======================

10.1 Sort by Keys
```python
# Method 1: Using sorted() with items()
sorted_dict = dict(sorted(my_dict.items()))

# Method 2: Manual sorting
sorted_keys = sorted(my_dict.keys())
sorted_dict = {key: my_dict[key] for key in sorted_keys}

# Method 3: Using OrderedDict
from collections import OrderedDict
sorted_dict = OrderedDict(sorted(my_dict.items()))
```

10.2 Sort by Values
```python
# Ascending order
sorted_dict = dict(sorted(my_dict.items(), key=lambda x: x[1]))

# Descending order
sorted_dict = dict(sorted(my_dict.items(), key=lambda x: x[1], reverse=True))

# Using OrderedDict
from collections import OrderedDict
sorted_dict = OrderedDict(sorted(my_dict.items(), key=lambda x: x[1]))
```

10.3 Custom Sorting
```python
# Sort by key length
sorted_dict = dict(sorted(my_dict.items(), key=lambda x: len(x[0])))

# Sort by multiple criteria
sorted_dict = dict(sorted(my_dict.items(), key=lambda x: (x[1], x[0])))
```

=====================================

11. DICTIONARY MERGING
=======================

11.1 Pipe Operator (Python 3.9+)
```python
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
merged = dict1 | dict2
# For overlapping keys, dict2 values take precedence
```

11.2 update() Method
```python
dict1.update(dict2)  # Modifies dict1 in place
```

11.3 Dictionary Unpacking
```python
merged = {**dict1, **dict2}
```

11.4 Merge with Processing
```python
# Merge and sort by values
dict3 = dict1 | dict2
dict3 = dict(sorted(dict3.items(), key=lambda x: x[1], reverse=True))
```

=====================================

12. BUILT-IN FUNCTIONS WITH DICTIONARIES
=========================================

12.1 min() and max() Functions
```python
# Find key with minimum value
min_key = min(my_dict, key=my_dict.get)

# Find key with maximum value
max_key = max(my_dict, key=my_dict.get)

# Find shortest/longest key by length
shortest_key = min(my_dict, key=lambda x: len(x))
longest_key = max(my_dict, key=lambda x: len(x))
```

12.2 sorted() Function
```python
# Sort keys
sorted_keys = sorted(my_dict.keys())

# Sort by values
sorted_items = sorted(my_dict.items(), key=lambda x: x[1])
```

12.3 zip() Function
```python
# Create dictionary from two lists
keys = ['a', 'b', 'c']
values = [1, 2, 3]
my_dict = dict(zip(keys, values))
```

12.4 enumerate() Function
```python
# Add index to dictionary values
items = ['apple', 'banana', 'cherry']
indexed_dict = {i: item for i, item in enumerate(items)}
```

=====================================

13. BEST PRACTICES AND COMMON PATTERNS
=======================================

13.1 Safe Key Access
```python
# Use get() instead of direct access for optional keys
value = my_dict.get('optional_key', 'default_value')

# Check existence before access
if 'key' in my_dict:
    value = my_dict['key']
```

13.2 Frequency Counting Pattern
```python
# Character/word frequency
frequency = {}
for item in items:
    frequency[item] = frequency.get(item, 0) + 1

# Alternative using defaultdict
from collections import defaultdict
frequency = defaultdict(int)
for item in items:
    frequency[item] += 1
```

13.3 Grouping Pattern
```python
# Group items by category
groups = {}
for item in items:
    category = get_category(item)
    if category not in groups:
        groups[category] = []
    groups[category].append(item)

# Using setdefault
groups = {}
for item in items:
    category = get_category(item)
    groups.setdefault(category, []).append(item)
```

13.4 Dictionary Inversion
```python
# Simple inversion (assumes unique values)
inverted = {value: key for key, value in original.items()}

# Handle duplicate values
inverted = {}
for key, value in original.items():
    if value not in inverted:
        inverted[value] = []
    inverted[value].append(key)
```

13.5 Key Renaming
```python
# Rename single key
my_dict['new_key'] = my_dict.pop('old_key')

# Rename multiple keys
key_mapping = {'old_key1': 'new_key1', 'old_key2': 'new_key2'}
for old_key, new_key in key_mapping.items():
    if old_key in my_dict:
        my_dict[new_key] = my_dict.pop(old_key)
```

13.6 Filtering Dictionaries
```python
# Filter by keys
filtered = {k: v for k, v in my_dict.items() if k in allowed_keys}

# Filter by values
filtered = {k: v for k, v in my_dict.items() if v > threshold}

# Filter by condition
filtered = {k: v for k, v in my_dict.items() if condition(k, v)}
```

13.7 Default Value Initialization
```python
# Initialize multiple keys with same default
keys = ['key1', 'key2', 'key3']
default_value = {'count': 0, 'status': 'active'}
my_dict = dict.fromkeys(keys, default_value)

# Note: Be careful with mutable defaults - they share the same object
# Better approach for mutable defaults:
my_dict = {key: {'count': 0, 'status': 'active'} for key in keys}
```

=====================================

14. ERROR HANDLING AND SAFETY
==============================

14.1 KeyError Handling
```python
# Try-except approach
try:
    value = my_dict['key']
except KeyError:
    value = 'default'

# get() method approach (preferred)
value = my_dict.get('key', 'default')
```

14.2 Type Safety
```python
# Check if object is a dictionary
if isinstance(obj, dict):
    # Safe to use dictionary methods
    pass

# Check if key exists before operations
if 'key' in my_dict and isinstance(my_dict['key'], dict):
    # Safe to access nested dictionary
    nested_value = my_dict['key']['nested_key']
```

14.3 Validation Patterns
```python
def validate_dict_structure(data, required_keys):
    """Validate dictionary has required keys"""
    missing_keys = set(required_keys) - set(data.keys())
    if missing_keys:
        raise ValueError(f"Missing required keys: {missing_keys}")
    return True

def safe_nested_get(dictionary, path, default=None):
    """Safely get nested dictionary value"""
    current = dictionary
    for key in path:
        if isinstance(current, dict) and key in current:
            current = current[key]
        else:
            return default
    return current
```

=====================================

15. PERFORMANCE CONSIDERATIONS
===============================

15.1 Dictionary vs List for Lookups
```python
# Dictionary lookup: O(1) average case
if key in my_dict:  # Fast

# List lookup: O(n)
if item in my_list:  # Slow for large lists
```

15.2 Memory Considerations
```python
# Dictionaries use more memory than lists
# Use dictionaries when you need fast key-based access
# Use lists when you need ordered data and don't need key lookups
```

15.3 Dictionary Comprehension vs Loop
```python
# Dictionary comprehension (generally faster)
result = {k: v for k, v in items if condition(k, v)}

# Traditional loop (more readable for complex logic)
result = {}
for k, v in items:
    if condition(k, v):
        result[k] = v
```

=====================================

16. COMMON USE CASES AND EXAMPLES
==================================

16.1 Configuration Management
```python
config = {
    'database': {
        'host': 'localhost',
        'port': 5432,
        'name': 'mydb'
    },
    'api': {
        'timeout': 30,
        'retries': 3
    }
}
```

16.2 Caching/Memoization
```python
cache = {}
def expensive_function(arg):
    if arg in cache:
        return cache[arg]
    result = compute_expensive_result(arg)
    cache[arg] = result
    return result
```

16.3 Data Transformation
```python
# Transform list of dictionaries
users = [
    {'name': 'Alice', 'age': 30},
    {'name': 'Bob', 'age': 25}
]

# Index by name
users_by_name = {user['name']: user for user in users}

# Group by age
from collections import defaultdict
users_by_age = defaultdict(list)
for user in users:
    users_by_age[user['age']].append(user)
```

16.4 State Management
```python
game_state = {
    'player': {
        'health': 100,
        'position': {'x': 0, 'y': 0},
        'inventory': ['sword', 'potion']
    },
    'level': 1,
    'score': 0
}
```

=====================================

SUMMARY OF KEY METHODS AND OPERATIONS
======================================

Dictionary Creation:
- {} or dict()
- dict.fromkeys()
- Dictionary comprehension
- zip() with dict()

Access Methods:
- dict[key]
- dict.get(key, default)

Modification:
- dict[key] = value
- dict.update()
- dict.setdefault()

Removal:
- del dict[key]
- dict.pop(key, default)
- dict.popitem()
- dict.clear()

Iteration:
- dict.keys()
- dict.values()
- dict.items()

Utility:
- len(dict)
- key in dict
- dict.copy()

Built-in Functions:
- min(dict, key=dict.get)
- max(dict, key=dict.get)
- sorted(dict.items())

Advanced Operations:
- Dictionary merging (|, update, **)
- Nested dictionary access
- Dictionary comprehensions
- Sorting by keys/values

=====================================

This comprehensive guide covers all dictionary methods, keywords, and use cases demonstrated in the Python Dictionary Exercise files, providing both theoretical knowledge and practical examples for effective dictionary usage in Python programming.