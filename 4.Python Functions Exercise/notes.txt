PYTHON FUNCTIONS COMPREHENSIVE NOTES
====================================

TABLE OF CONTENTS
-----------------
1. Function Basics and Definition
2. Function Parameters and Arguments
3. Variable Arguments (*args and **kwargs)
4. Default Parameters
5. Return Values and Multiple Returns
6. Nested Functions
7. Recursive Functions
8. Function Aliasing and References
9. Lambda Functions (Anonymous Functions)
10. Higher-Order Functions
11. Built-in Functions with Functions
12. Global and Local Variables
13. Function Scope and Closures
14. Functional Programming Concepts
15. Advanced Function Techniques
16. Best Practices and Common Patterns

===============================

1. FUNCTION BASICS AND DEFINITION
==================================

Function Definition:
- Functions are reusable blocks of code that perform specific tasks
- Defined using the 'def' keyword
- Can accept parameters and return values
- Promote code reusability and organization

Basic Syntax:
    def function_name(parameters):
        """Optional docstring"""
        # Function body
        return value  # Optional

Simple Function Example:
    def person(name, age):
        print(f'Hi {name}, your now {age} year old.')
    
    # Function call
    person('Angelou', 13)

Key Concepts:
- Function definition vs function call
- Parameters vs arguments
- Function body and indentation
- Return statement (optional)

Use Cases:
- Code organization and modularity
- Avoiding code repetition
- Creating reusable components
- Breaking complex problems into smaller parts

===============================

2. FUNCTION PARAMETERS AND ARGUMENTS
====================================

Types of Arguments:

Positional Arguments:
- Arguments passed in specific order
- Position matters
    def describe_pet(animal_type, pet_name):
        print(f'{pet_name} and a {animal_type}')
    
    describe_pet('hustkou', 'hunter')  # Positional

Keyword Arguments:
- Arguments passed with parameter names
- Order doesn't matter
    describe_pet(animal_type='hello', pet_name='huntest')

Parameter Types:
- Required parameters (no default value)
- Optional parameters (with default values)
- Variable-length parameters (*args, **kwargs)

Function Signature:
    def function_name(required_param, optional_param=default_value):
        pass

Use Cases:
- Flexible function calls
- Clear parameter specification
- Avoiding argument order confusion
- Making functions more readable

===============================

3. VARIABLE ARGUMENTS (*args and **kwargs)
===========================================

*args (Variable Positional Arguments):
- Accepts any number of positional arguments
- Arguments stored as tuple
- Useful when number of arguments is unknown

Syntax and Example:
    def func1(*args):
        for number in args:
            print(number)
    
    func1(10, 20)              # 2 arguments
    func1("hello", 3.14, True) # 3 arguments
    func1(1, 2, 3, 4, 5)       # 5 arguments
    func1()                    # No arguments

**kwargs (Variable Keyword Arguments):
- Accepts any number of keyword arguments
- Arguments stored as dictionary
- Keys are parameter names, values are argument values

Syntax and Example:
    def print_info(**kwargs):
        for key, value in kwargs.items():
            print(f'{key} is {value}')
    
    print_info(name='Angelou', age=25, status='Unemployed')

Combined Usage:
    def store_key_value(**k):
        dict = {}
        for key, value in k.items():
            dict[key] = value
        return dict

Use Cases:
- Functions with flexible argument counts
- Configuration functions
- Wrapper functions
- API functions with optional parameters

===============================

4. DEFAULT PARAMETERS
======================

Default Parameter Values:
- Parameters can have default values
- Used when argument not provided
- Must come after required parameters

Syntax:
    def show_employee(name, salary=9000):
        print(f'Name: {name:<3} Salary: {salary:<3}')

Usage Examples:
    show_employee('Angelou', 8000)  # Both parameters
    show_employee('Angelou')        # Uses default salary

Rules for Default Parameters:
- Default parameters must follow non-default parameters
- Default values evaluated once at function definition
- Mutable defaults can cause unexpected behavior

Best Practices:
    # Good - immutable defaults
    def greet(name, greeting="Hello"):
        return f"{greeting}, {name}!"
    
    # Avoid - mutable defaults
    def add_item(item, target_list=None):
        if target_list is None:
            target_list = []
        target_list.append(item)
        return target_list

Use Cases:
- Optional configuration parameters
- Backward compatibility
- Simplifying function calls
- Providing sensible defaults

===============================

5. RETURN VALUES AND MULTIPLE RETURNS
======================================

Single Return Value:
    def square(x):
        return x * x

Multiple Return Values:
- Python functions can return multiple values as tuple
- Values can be unpacked into separate variables

Example:
    def calculation(num1, num2):
        addition = num1 + num2
        subtraction = num1 - num2
        return addition, subtraction
    
    # Unpacking return values
    sum_result, diff_result = calculation(40, 10)
    
    # Or as tuple
    result = calculation(40, 10)  # result is (50, 30)

Return Types:
- Single values (int, string, list, etc.)
- Multiple values (tuple)
- Collections (list, dict, set)
- Objects and custom types
- None (implicit if no return statement)

Early Returns:
    def find_max(numbers):
        if not numbers:
            return None  # Early return for empty list
        
        max_val = numbers[0]
        for num in numbers:
            if num > max_val:
                max_val = num
        return max_val

Use Cases:
- Returning calculated results
- Status and data combinations
- Multiple related values
- Error handling with status codes

===============================

6. NESTED FUNCTIONS
====================

Definition:
- Functions defined inside other functions
- Inner functions have access to outer function's variables
- Create closures and encapsulation

Basic Example:
    def calculate(a, b):
        def sum(a, b):
            return a + b
        
        result = sum(a, b) + 5
        return result
    
    print(calculate(10, 10))  # Output: 25

Closure Example:
    def outer_function(x):
        def inner_function(y):
            return x + y  # Access to outer variable
        return inner_function
    
    add_five = outer_function(5)
    result = add_five(3)  # Returns 8

Benefits:
- Encapsulation of helper functions
- Access to outer scope variables
- Creating specialized functions
- Data hiding and privacy

Advanced Pattern:
    def create_multiplier(factor):
        def multiply(number):
            return number * factor
        return multiply
    
    double = create_multiplier(2)
    triple = create_multiplier(3)
    
    print(double(5))   # 10
    print(triple(5))   # 15

Use Cases:
- Helper functions that don't need global scope
- Closures for maintaining state
- Decorator implementations
- Factory functions

===============================

7. RECURSIVE FUNCTIONS
=======================

Definition:
- Functions that call themselves
- Must have base case to prevent infinite recursion
- Useful for problems with recursive structure

Basic Recursion Pattern:
    def recursive_function(parameter):
        # Base case
        if base_condition:
            return base_value
        # Recursive case
        else:
            return recursive_function(modified_parameter)

Simple Sum Example:
    def recursive_sum(num):
        if num:  # Base case: num != 0
            return num + recursive_sum(num - 1)
        else:
            return 0  # Base case: num == 0
    
    print(recursive_sum(10))  # Returns 55

Factorial Example:
    def factorial(number):
        if number == 0 or number == 1:  # Base case
            return 1
        else:  # Recursive case
            return number * factorial(number - 1)
    
    print(factorial(5))  # Returns 120

Recursion Components:
1. Base Case: Condition that stops recursion
2. Recursive Case: Function calls itself with modified input
3. Progress: Each call moves toward base case

Common Recursive Problems:
- Mathematical sequences (factorial, fibonacci)
- Tree traversal
- Directory scanning
- Divide and conquer algorithms

Use Cases:
- Mathematical calculations
- Tree and graph algorithms
- Parsing nested structures
- Backtracking problems

===============================

8. FUNCTION ALIASING AND REFERENCES
====================================

Function Aliasing:
- Functions are objects in Python
- Can be assigned to variables
- Multiple names can reference same function

Example:
    def display_student(name, age):
        print(name, age)
    
    # Create alias
    show_student = display_student
    
    # Both work identically
    display_student("Emma", 26)
    show_student('Angelou', 40)

Function as Variables:
    # Functions can be stored in data structures
    operations = {
        'add': lambda x, y: x + y,
        'subtract': lambda x, y: x - y,
        'multiply': lambda x, y: x * y
    }
    
    result = operations['add'](5, 3)  # 8

Passing Functions as Arguments:
    def apply_twice(func, value):
        return func(func(value))
    
    def square(x):
        return x * x
    
    result = apply_twice(square, 3)  # square(square(3)) = 81

Use Cases:
- Creating function shortcuts
- Dynamic function selection
- Callback functions
- Function registries

===============================

9. LAMBDA FUNCTIONS (ANONYMOUS FUNCTIONS)
==========================================

Definition:
- Small anonymous functions defined with lambda keyword
- Can have multiple arguments but only one expression
- Return value of expression automatically

Basic Syntax:
    lambda arguments: expression

Simple Examples:
    # Lambda inside function
    def get_square(num):
        square = lambda num: num ** 2
        return square(num)
    
    # Direct lambda usage
    add = lambda x, y: x + y
    result = add(5, 3)  # 8

Lambda with Built-in Functions:

Filter Example:
    def get_even(lst):
        even_list = list(filter(lambda element: element % 2 == 0, lst))
        return even_list
    
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    evens = get_even(numbers)  # [2, 4, 6, 8, 10]

Map Example:
    def lambda_map(lst):
        res = list(map(lambda x: x * 2, lst))
        return res
    
    numbers = [1, 2, 3, 4, 5]
    doubled = lambda_map(numbers)  # [2, 4, 6, 8, 10]

Sorting with Lambda:
    def sorted_tuples(lst):
        # Sort by second element of each tuple
        new_list = sorted(lst, key=lambda element: element[1])
        return new_list
    
    data = [('apple', 5), ('banana', 2), ('cherry', 8)]
    sorted_data = sorted_tuples(data)  # [('banana', 2), ('apple', 5), ('cherry', 8)]

Use Cases:
- Short, simple functions
- Callback functions
- Functional programming
- Data processing with map, filter, sort

===============================

10. HIGHER-ORDER FUNCTIONS
===========================

Definition:
- Functions that take other functions as arguments
- Functions that return other functions
- Enable functional programming patterns

Function as Parameter:
    def apply_operation(func, x, y):
        return func(x, y)
    
    # Lambda functions for operations
    addition = lambda x, y: x + y
    subtraction = lambda x, y: x - y
    multiplication = lambda x, y: x * y
    
    # Using higher-order function
    sum_result = apply_operation(addition, 10, 5)        # 15
    diff_result = apply_operation(subtraction, 10, 5)    # 5
    prod_result = apply_operation(multiplication, 10, 5) # 50

Function Factory:
    def create_operation(operation):
        if operation == 'add':
            return lambda x, y: x + y
        elif operation == 'multiply':
            return lambda x, y: x * y
        else:
            return lambda x, y: 0
    
    adder = create_operation('add')
    result = adder(3, 4)  # 7

Decorator Pattern:
    def timing_decorator(func):
        def wrapper(*args, **kwargs):
            import time
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            print(f"Function took {end - start} seconds")
            return result
        return wrapper

Use Cases:
- Callback functions
- Event handling
- Decorators
- Functional programming
- Strategy pattern implementation

===============================

11. BUILT-IN FUNCTIONS WITH FUNCTIONS
======================================

map(function, iterable):
- Applies function to each item in iterable
- Returns map object (iterator)

    numbers = [1, 2, 3, 4, 5]
    squared = list(map(lambda x: x**2, numbers))  # [1, 4, 9, 16, 25]

filter(function, iterable):
- Filters items based on function returning True
- Returns filter object (iterator)

    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    evens = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4, 6, 8, 10]

sorted(iterable, key=function):
- Sorts iterable using key function
- Returns new sorted list

    students = [('Alice', 85), ('Bob', 90), ('Charlie', 78)]
    by_grade = sorted(students, key=lambda x: x[1])  # Sort by grade

reduce(function, iterable):
- Applies function cumulatively to items
- Requires import from functools

    from functools import reduce
    numbers = [1, 2, 3, 4, 5]
    sum_all = reduce(lambda x, y: x + y, numbers)  # 15

any(iterable):
- Returns True if any element is True

    has_even = any(x % 2 == 0 for x in [1, 3, 5, 6])  # True

all(iterable):
- Returns True if all elements are True

    all_positive = all(x > 0 for x in [1, 2, 3, 4])  # True

Use Cases:
- Data transformation
- Filtering and selection
- Aggregation operations
- Functional programming patterns

===============================

12. GLOBAL AND LOCAL VARIABLES
===============================

Variable Scope:
- Local: Variables defined inside functions
- Global: Variables defined outside functions
- Function parameters are local variables

Local Variables:
    def my_function():
        local_var = 10  # Local variable
        print(local_var)

Global Variables:
    global_var = 20  # Global variable
    
    def access_global():
        print(global_var)  # Can read global variable

Modifying Global Variables:
    global_var = 10
    
    def update_global():
        global global_var  # Declare global usage
        for i in range(5):
            global_var += 1
            print(global_var)
    
    update_global()  # Modifies global_var

Variable Lookup Order (LEGB Rule):
1. Local - Inside current function
2. Enclosing - In enclosing functions
3. Global - At module level
4. Built-in - Built-in names

Example:
    x = "global"
    
    def outer():
        x = "enclosing"
        
        def inner():
            x = "local"
            print(x)  # Prints "local"
        
        inner()
        print(x)  # Prints "enclosing"
    
    outer()
    print(x)  # Prints "global"

Best Practices:
- Minimize global variable usage
- Use function parameters instead
- Use return values for communication
- Be explicit with global keyword

Use Cases:
- Configuration variables
- Shared state (use carefully)
- Constants
- Module-level variables

===============================

13. FUNCTION SCOPE AND CLOSURES
================================

Closure Definition:
- Inner function that captures variables from outer scope
- Variables remain accessible even after outer function returns
- Creates persistent local environment

Basic Closure:
    def outer_function(x):
        def inner_function(y):
            return x + y  # Captures 'x' from outer scope
        return inner_function
    
    add_five = outer_function(5)  # Creates closure
    result = add_five(3)  # Uses captured 'x' value: 8

Closure with State:
    def create_counter():
        count = 0
        
        def increment():
            nonlocal count  # Modify enclosing scope variable
            count += 1
            return count
        
        return increment
    
    counter1 = create_counter()
    counter2 = create_counter()
    
    print(counter1())  # 1
    print(counter1())  # 2
    print(counter2())  # 1 (separate closure)

Factory Functions:
    def create_multiplier(factor):
        def multiply(number):
            return number * factor
        return multiply
    
    double = create_multiplier(2)
    triple = create_multiplier(3)
    
    print(double(4))   # 8
    print(triple(4))   # 12

nonlocal Keyword:
- Allows modification of enclosing scope variables
- Similar to global but for nested functions

    def outer():
        x = 10
        
        def inner():
            nonlocal x
            x += 1
            return x
        
        return inner

Use Cases:
- Creating specialized functions
- Maintaining state without classes
- Decorator implementations
- Event handlers with context

===============================

14. FUNCTIONAL PROGRAMMING CONCEPTS
====================================

Pure Functions:
- Same input always produces same output
- No side effects (don't modify external state)
- Easier to test and reason about

    # Pure function
    def add(x, y):
        return x + y
    
    # Impure function (has side effect)
    counter = 0
    def increment():
        global counter
        counter += 1
        return counter

Immutability:
- Prefer creating new data rather than modifying existing
- Use tuples instead of lists when data won't change
- Return new collections rather than modifying parameters

Function Composition:
    def compose(f, g):
        return lambda x: f(g(x))
    
    def add_one(x):
        return x + 1
    
    def multiply_two(x):
        return x * 2
    
    # Compose functions
    add_then_multiply = compose(multiply_two, add_one)
    result = add_then_multiply(3)  # (3 + 1) * 2 = 8

Currying:
    def curry_add(x):
        def add_x(y):
            return x + y
        return add_x
    
    add_five = curry_add(5)
    result = add_five(3)  # 8

Partial Application:
    from functools import partial
    
    def multiply(x, y, z):
        return x * y * z
    
    # Create partially applied function
    double = partial(multiply, 2)
    result = double(3, 4)  # 2 * 3 * 4 = 24

Use Cases:
- Data processing pipelines
- Mathematical computations
- Parallel processing
- Functional reactive programming

===============================

15. ADVANCED FUNCTION TECHNIQUES
=================================

Decorators:
- Functions that modify or extend other functions
- Use @ syntax for clean application

    def my_decorator(func):
        def wrapper(*args, **kwargs):
            print("Before function call")
            result = func(*args, **kwargs)
            print("After function call")
            return result
        return wrapper
    
    @my_decorator
    def greet(name):
        print(f"Hello, {name}!")
    
    greet("Alice")  # Prints before, greeting, after

Generator Functions:
- Functions that yield values instead of returning
- Create iterators efficiently

    def fibonacci_generator(n):
        a, b = 0, 1
        for _ in range(n):
            yield a
            a, b = b, a + b
    
    fib = fibonacci_generator(10)
    for num in fib:
        print(num)

Function Annotations:
- Provide hints about parameter and return types
- Don't affect runtime behavior

    def greet(name: str, age: int) -> str:
        return f"Hello {name}, you are {age} years old"

Memoization:
- Cache function results for performance
- Useful for expensive recursive functions

    def memoize(func):
        cache = {}
        def wrapper(*args):
            if args in cache:
                return cache[args]
            result = func(*args)
            cache[args] = result
            return result
        return wrapper
    
    @memoize
    def fibonacci(n):
        if n < 2:
            return n
        return fibonacci(n-1) + fibonacci(n-2)

Use Cases:
- Performance optimization
- Code organization
- Aspect-oriented programming
- API design

===============================

16. BEST PRACTICES AND COMMON PATTERNS
=======================================

Function Design Principles:
1. Single Responsibility: One function, one task
2. Pure Functions: Avoid side effects when possible
3. Clear Names: Function names should describe what they do
4. Reasonable Length: Keep functions focused and concise
5. Documentation: Use docstrings for complex functions

Naming Conventions:
    # Good function names
    def calculate_total_price(items):
        pass
    
    def is_valid_email(email):
        pass
    
    def get_user_by_id(user_id):
        pass

Error Handling:
    def safe_divide(a, b):
        """Safely divide two numbers."""
        try:
            return a / b
        except ZeroDivisionError:
            return None
        except TypeError:
            raise ValueError("Arguments must be numbers")

Documentation:
    def calculate_compound_interest(principal, rate, time, compound_frequency=1):
        """
        Calculate compound interest.
        
        Args:
            principal (float): Initial amount
            rate (float): Annual interest rate (as decimal)
            time (float): Time in years
            compound_frequency (int): Times compounded per year
        
        Returns:
            float: Final amount after compound interest
        
        Example:
            >>> calculate_compound_interest(1000, 0.05, 2)
            1102.5
        """
        return principal * (1 + rate/compound_frequency) ** (compound_frequency * time)

Testing Functions:
    def test_calculate_total():
        assert calculate_total([1, 2, 3]) == 6
        assert calculate_total([]) == 0
        assert calculate_total([5]) == 5

Performance Considerations:
- Use generators for large datasets
- Avoid global variables
- Cache expensive computations
- Use appropriate data structures

Common Patterns:
    # Factory pattern
    def create_user(user_type):
        if user_type == 'admin':
            return AdminUser()
        elif user_type == 'regular':
            return RegularUser()
    
    # Strategy pattern
    def process_payment(amount, method):
        processors = {
            'credit': process_credit_card,
            'paypal': process_paypal,
            'bitcoin': process_bitcoin
        }
        return processors[method](amount)
    
    # Template method
    def data_processor(data, validator, transformer, saver):
        if validator(data):
            processed = transformer(data)
            return saver(processed)
        return None

===============================

SUMMARY OF FUNCTION CONCEPTS
=============================

Function Types:
- Regular functions (def)
- Lambda functions (anonymous)
- Nested functions (closures)
- Recursive functions
- Generator functions
- Decorated functions

Parameter Types:
- Positional parameters
- Keyword parameters
- Default parameters
- Variable positional (*args)
- Variable keyword (**kwargs)

Function Features:
- Return values (single/multiple)
- Function aliasing
- Higher-order functions
- Closures and scope
- Global/local variables

Built-in Function Tools:
- map()                  # Apply function to iterable
- filter()               # Filter with function
- sorted()               # Sort with key function
- reduce()               # Cumulative function application
- any()/all()            # Boolean aggregation

Keywords:
- def                    # Define function
- return                 # Return value
- lambda                 # Anonymous function
- global                 # Global variable access
- nonlocal               # Enclosing scope access
- yield                  # Generator function

Advanced Concepts:
- Decorators             # Function modification
- Closures               # Captured variables
- Memoization            # Result caching
- Currying               # Partial application
- Function composition   # Combining functions

===============================

This comprehensive guide covers all function concepts, patterns, and techniques demonstrated in the Python Functions Exercise files. Each concept includes syntax, examples, and practical applications for effective function design and implementation.